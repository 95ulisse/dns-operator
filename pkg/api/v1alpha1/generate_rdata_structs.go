// +build ignore

// generate_rdata_structs.go is meant to run with go generate. It will use
// go/{importer,types} to track down all the RR struct types from miekg/dns.
// Part of the logic in this file is borrowed from miekg/dns's own generator program:
// https://github.com/miekg/dns/blob/master/msg_generate.go
package main

import (
	"bytes"
	"fmt"
	"go/format"
	"go/types"
	"log"
	"os"
	"strings"

	"golang.org/x/tools/go/packages"
)

var packageHdr = `
// Code generated by generate_rdata_structs.go. DO NOT EDIT.

package v1alpha1

import (
	"fmt"
	"net"
	
	"github.com/miekg/dns"

	dnsname "github.com/95ulisse/dns-operator/pkg/dnsname"
)

// Ipv4String is a string containing an IPv4 address.
// +kubebuilder:validation:Format=ipv4
type Ipv4String string

// Ipv6String is a string containing an IPv6 address.
// +kubebuilder:validation:Format=ipv6
type Ipv6String string

// TxtString is a string used as contents of a TXT record.
type TxtString string

func _a(source *Ipv4String, target *net.IP) error {
	ip := net.ParseIP(string(*source))
	if ip == nil {
		return  fmt.Errorf("Invalid IPv4 address %s", *source)
	}
	ip = ip.To4()
	if ip == nil {
		return fmt.Errorf("Invalid IPv4 address %s", *source)
	}
	*target = ip
	return nil
}

func _aaaa(source *Ipv6String, target *net.IP) error {
	ip := net.ParseIP(string(*source))
	if ip == nil {
		return  fmt.Errorf("Invalid IPv6 address %s", *source)
	}
	ip = ip.To16()
	if ip == nil {
		return fmt.Errorf("Invalid IPv6 address %s", *source)
	}
	*target = ip
	return nil
}

func _name(source *dnsname.Name, target *string) error {
	*target = source.String()
	return nil
}

func _txt(source *TxtString, target *[]string) error {

	// Split the source stirng in chunks of 255 bytes
	chunkSize := 255
	if chunkSize >= len(*source) {
		*target = []string{string(*source)}
		return nil
	}
	var chunks []string
	chunk := make([]rune, chunkSize)
	len := 0
	for _, r := range *source {
		chunk[len] = r
		len++
		if len == chunkSize {
			chunks = append(chunks, string(chunk))
			len = 0
		}
	}
	if len > 0 {
		chunks = append(chunks, string(chunk[:len]))
	}

	*target = chunks
	return nil
}

`

var rtypesToGenerate = []string{"A", "AAAA", "MX", "CNAME", "TXT"}

var knownConversionFunctions = map[string]string{
	"Ipv4String":   "_a",
	"Ipv6String":   "_aaaa",
	"dnsname.Name": "_name",
	"TxtString":    "_txt",
}

func fatalIfErr(err error) {
	if err != nil {
		log.Fatal(err)
	}
}

// getTypeStruct will take a type and the package scope, and return the
// (innermost) struct if the type is considered a RR type (currently defined as
// those structs beginning with a RR_Header, could be redefined as implementing
// the RR interface). The bool return value indicates if embedded structs were
// resolved.
func getTypeStruct(t types.Type, scope *types.Scope) (*types.Struct, bool) {
	st, ok := t.Underlying().(*types.Struct)
	if !ok {
		return nil, false
	}
	if st.NumFields() == 0 {
		return nil, false
	}
	if st.Field(0).Type() == scope.Lookup("RR_Header").Type() {
		return st, false
	}
	if st.Field(0).Anonymous() {
		st, _ := getTypeStruct(st.Field(0).Type(), scope)
		return st, true
	}
	return nil, false
}

func mapMiekgFieldType(st *types.Struct, i int) string {
	// Each field in the dns library can have a tag to express more info about its serialization strategy,
	// which is very useful for us to implement a more accurate validation.
	switch st.Tag(i) {
	case `dns:"a"`:
		return "Ipv4String"
	case `dns:"aaaa"`:
		return "Ipv6String"
	case `dns:"cdomain-name"`:
		fallthrough
	case `dns:"domain-name"`:
		return "dnsname.Name"
	case `dns:"txt"`:
		return "TxtString"
	case "":
		switch st.Field(i).Type().(*types.Basic).Kind() {
		case types.Uint8:
			return "uint8"
		case types.Uint16:
			return "uint16"
		case types.Uint32:
			return "uint32"
		case types.Uint64:
			return "uint64"
		case types.String:
			return "string"
		}
	}

	return ""
}

func getTargetTypeForStruct(name string, st *types.Struct) (targetType string, secondaryStruct string) {

	// miekg/dns's rdata structs are all like this:
	//
	// type A struct {
	//   Hdr RR_Header           // Common header
	//   A   net.IP `dns:"a"`    // One or more fields with a tag
	// }

	// If the struct has a single field, we do not need to generate a secondary struct
	if st.NumFields() == 2 {
		targetType = mapMiekgFieldType(st, 1)
		return
	}

	var sb strings.Builder
	fmt.Fprintf(&sb, "// %sRData represents the contents of an %s DNS record.\ntype %sRData struct {\n", name, name, name)

	// Note that we always skip the first field, which is the common header for all types
	for i := 1; i < st.NumFields(); i++ {
		targetType = mapMiekgFieldType(st, i)
		if targetType == "" {
			return
		}

		fieldName := st.Field(i).Name()
		fmt.Fprintf(&sb, "%s %s `json:\"%s\"`\n", fieldName, targetType, strings.ToLower(fieldName))
	}

	sb.WriteString("\n}")
	targetType = name + "RData"
	secondaryStruct = sb.String()
	return

}

func generateConversionCode(name string, st *types.Struct) string {

	var sb strings.Builder

	o := func(src, fieldName, t string) {
		if f, ok := knownConversionFunctions[t]; ok {
			fmt.Fprintf(&sb, "if err := %s(&%s, &rr.%s); err != nil {\nreturn nil, err\n}\n", f, src, fieldName)
		} else {
			fmt.Fprintf(&sb, "rr.%s = %s\n", fieldName, src)
		}
	}

	if st.NumFields() == 2 {
		o("value", st.Field(1).Name(), mapMiekgFieldType(st, 1))
	} else {
		for i := 1; i < st.NumFields(); i++ {
			fieldName := st.Field(i).Name()
			o("value."+fieldName, fieldName, mapMiekgFieldType(st, i))
		}
	}

	return sb.String()

}

// loadModule retrieves package description for a given module.
func loadModule(name string) (*types.Package, error) {
	conf := packages.Config{Mode: packages.NeedTypes | packages.NeedTypesInfo}
	pkgs, err := packages.Load(&conf, name)
	if err != nil {
		return nil, err
	}
	return pkgs[0].Types, nil
}

func main() {

	// Import and type-check the package
	pkg, err := loadModule("github.com/miekg/dns")
	fatalIfErr(err)
	scope := pkg.Scope()

	b := &bytes.Buffer{}
	b.WriteString(packageHdr)

	// Begin the `DNSRecordData` struct definition.
	// Such struct is composed by a field for each single rdata type we support.
	secondaryStructs := make([]string, 0)
	fmt.Fprint(b, "// DNSRecordData represents the actual contents of a DNS record. Only one of these can be set.\n")
	fmt.Fprint(b, "type DNSRecordData struct {\n")
	for _, name := range rtypesToGenerate {

		o := scope.Lookup(name)
		st, _ := getTypeStruct(o.Type(), scope)
		targetType, secondaryStruct := getTargetTypeForStruct(name, st)
		if targetType == "" {
			log.Fatalf("Unsupported struct %s", name)
		}
		if secondaryStruct != "" {
			secondaryStructs = append(secondaryStructs, secondaryStruct)
		}

		fmt.Fprintf(b, `
			// %s record.
			// +kubebuilder:validation:MinItems=1
			// +optional
			%s []%s `+"`json:\"%s,omitempty\"`"+`
		`, name, name, targetType, strings.ToLower(name))
	}
	fmt.Fprintf(b, "}\n")

	// Print all the additional structs
	for _, s := range secondaryStructs {
		fmt.Fprintf(b, "\n%s\n", s)
	}

	// Generate the `ToRRSet` function
	fmt.Fprintf(b, `
		func toRRSet(name string, ttl uint32, spec *DNSRecordData) ([]dns.RR, error) {

			// Prepare a common header
			header := dns.RR_Header{
				Name:  name,
				Class: dns.ClassINET,
				Ttl:   ttl,
			}

	`)
	for _, name := range rtypesToGenerate {
		o := scope.Lookup(name)
		st, _ := getTypeStruct(o.Type(), scope)

		fmt.Fprintf(b, `
			// %s record
			if spec.%s != nil {
				rrset := make([]dns.RR, 0, 1)
				for _, value := range spec.%s {
					rr := new(dns.%s)
					rr.Hdr = header
					rr.Hdr.Rrtype = dns.Type%s
					%s
					rrset = append(rrset, rr)
				}
				return rrset, nil
			}
		`, name, name, name, name, name, generateConversionCode(name, st))
	}
	fmt.Fprintf(b, `
			return nil, fmt.Errorf("Unsupported DNS record")
		}
	`)

	// gofmt the generated source
	res, err := format.Source(b.Bytes())
	if err != nil {
		b.WriteTo(os.Stderr)
		log.Fatal(err)
	}

	// write result
	f, err := os.Create("zz_generated_rdata_structs.go")
	fatalIfErr(err)
	defer f.Close()
	f.Write(res)

}
