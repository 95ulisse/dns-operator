// Code generated by generate_rdata_structs.go. DO NOT EDIT.

package v1alpha1

import (
	"fmt"
	"net"

	"github.com/miekg/dns"

	dnsname "github.com/95ulisse/dns-operator/pkg/dnsname"
)

// Ipv4String is a string containing an IPv4 address.
// +kubebuilder:validation:Format=ipv4
type Ipv4String string

// Ipv6String is a string containing an IPv6 address.
// +kubebuilder:validation:Format=ipv6
type Ipv6String string

// TxtString is a string used as contents of a TXT record.
type TxtString string

func _a(source *Ipv4String, target *net.IP) error {
	ip := net.ParseIP(string(*source))
	if ip == nil {
		return fmt.Errorf("Invalid IPv4 address %s", *source)
	}
	ip = ip.To4()
	if ip == nil {
		return fmt.Errorf("Invalid IPv4 address %s", *source)
	}
	*target = ip
	return nil
}

func _aaaa(source *Ipv6String, target *net.IP) error {
	ip := net.ParseIP(string(*source))
	if ip == nil {
		return fmt.Errorf("Invalid IPv6 address %s", *source)
	}
	ip = ip.To16()
	if ip == nil {
		return fmt.Errorf("Invalid IPv6 address %s", *source)
	}
	*target = ip
	return nil
}

func _name(source *dnsname.Name, target *string) error {
	*target = source.String()
	return nil
}

func _txt(source *TxtString, target *[]string) error {

	// Split the source stirng in chunks of 255 bytes
	chunkSize := 255
	if chunkSize >= len(*source) {
		*target = []string{string(*source)}
		return nil
	}
	var chunks []string
	chunk := make([]rune, chunkSize)
	len := 0
	for _, r := range *source {
		chunk[len] = r
		len++
		if len == chunkSize {
			chunks = append(chunks, string(chunk))
			len = 0
		}
	}
	if len > 0 {
		chunks = append(chunks, string(chunk[:len]))
	}

	*target = chunks
	return nil
}

// DNSRecordData represents the actual contents of a DNS record. Only one of these can be set.
type DNSRecordData struct {

	// A record.
	// +kubebuilder:validation:MinItems=1
	// +optional
	A []Ipv4String `json:"a,omitempty"`

	// AAAA record.
	// +kubebuilder:validation:MinItems=1
	// +optional
	AAAA []Ipv6String `json:"aaaa,omitempty"`

	// MX record.
	// +kubebuilder:validation:MinItems=1
	// +optional
	MX []MXRData `json:"mx,omitempty"`

	// CNAME record.
	// +kubebuilder:validation:MinItems=1
	// +optional
	CNAME []dnsname.Name `json:"cname,omitempty"`

	// TXT record.
	// +kubebuilder:validation:MinItems=1
	// +optional
	TXT []TxtString `json:"txt,omitempty"`
}

// MXRData represents the contents of an MX DNS record.
type MXRData struct {
	Preference uint16       `json:"preference"`
	Mx         dnsname.Name `json:"mx"`
}

func toRRSet(name string, ttl uint32, spec *DNSRecordData) ([]dns.RR, error) {

	// Prepare a common header
	header := dns.RR_Header{
		Name:  name,
		Class: dns.ClassINET,
		Ttl:   ttl,
	}

	// A record
	if spec.A != nil {
		rrset := make([]dns.RR, 0, 1)
		for _, value := range spec.A {
			rr := new(dns.A)
			rr.Hdr = header
			rr.Hdr.Rrtype = dns.TypeA
			if err := _a(&value, &rr.A); err != nil {
				return nil, err
			}

			rrset = append(rrset, rr)
		}
		return rrset, nil
	}

	// AAAA record
	if spec.AAAA != nil {
		rrset := make([]dns.RR, 0, 1)
		for _, value := range spec.AAAA {
			rr := new(dns.AAAA)
			rr.Hdr = header
			rr.Hdr.Rrtype = dns.TypeAAAA
			if err := _aaaa(&value, &rr.AAAA); err != nil {
				return nil, err
			}

			rrset = append(rrset, rr)
		}
		return rrset, nil
	}

	// MX record
	if spec.MX != nil {
		rrset := make([]dns.RR, 0, 1)
		for _, value := range spec.MX {
			rr := new(dns.MX)
			rr.Hdr = header
			rr.Hdr.Rrtype = dns.TypeMX
			rr.Preference = value.Preference
			if err := _name(&value.Mx, &rr.Mx); err != nil {
				return nil, err
			}

			rrset = append(rrset, rr)
		}
		return rrset, nil
	}

	// CNAME record
	if spec.CNAME != nil {
		rrset := make([]dns.RR, 0, 1)
		for _, value := range spec.CNAME {
			rr := new(dns.CNAME)
			rr.Hdr = header
			rr.Hdr.Rrtype = dns.TypeCNAME
			if err := _name(&value, &rr.Target); err != nil {
				return nil, err
			}

			rrset = append(rrset, rr)
		}
		return rrset, nil
	}

	// TXT record
	if spec.TXT != nil {
		rrset := make([]dns.RR, 0, 1)
		for _, value := range spec.TXT {
			rr := new(dns.TXT)
			rr.Hdr = header
			rr.Hdr.Rrtype = dns.TypeTXT
			if err := _txt(&value, &rr.Txt); err != nil {
				return nil, err
			}

			rrset = append(rrset, rr)
		}
		return rrset, nil
	}

	return nil, fmt.Errorf("Unsupported DNS record")
}
