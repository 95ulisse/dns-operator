{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome \u00b6 dns-operator is an operator for Kubernetes which allows you to deploy DNS records as resources in you cluster. dns-operator introduces a new DNSRecord kind, which represents a single DNS record on the provider of your choice (e.g., Cloudflare or you own personal server) that you can deploy with kubectl , helm or any other tool you use for your deployments. For a quick overview of the core concepts of the operator, go to the Quick Start page, or, if you prefer a complete step-by-step guide, head over to one of the User Guides . Important dns-operator is not a substitute for a complete DNS management solution! This operator can help manage some of the most common record types as Kubernetes resources, leveraging its ecosystem of tools to ease deployments, but it is in no way a complete solution for all your DNS needs!","title":"Home"},{"location":"#welcome","text":"dns-operator is an operator for Kubernetes which allows you to deploy DNS records as resources in you cluster. dns-operator introduces a new DNSRecord kind, which represents a single DNS record on the provider of your choice (e.g., Cloudflare or you own personal server) that you can deploy with kubectl , helm or any other tool you use for your deployments. For a quick overview of the core concepts of the operator, go to the Quick Start page, or, if you prefer a complete step-by-step guide, head over to one of the User Guides . Important dns-operator is not a substitute for a complete DNS management solution! This operator can help manage some of the most common record types as Kubernetes resources, leveraging its ecosystem of tools to ease deployments, but it is in no way a complete solution for all your DNS needs!","title":"Welcome"},{"location":"roadmap/","text":"Roadmap \u00b6 Prometheus metrics Helm More record types","title":"Roadmap"},{"location":"roadmap/#roadmap","text":"Prometheus metrics Helm More record types","title":"Roadmap"},{"location":"getting-started/install/","text":"Installing dns-operator \u00b6 dns-operator runs in your cluster a regular deployment. It utilizes CustomResourceDefinitions to provide the new DNSProvider and DNSResource that you will later use. It is deployed with regular Kubernetes YAML manifests. Installing the manifests \u00b6 To install dns-operator in your cluster, use the all-in-one manifest. This will install the new CRDs and correctly setup RBAC roles. $ kubectl apply -f https://raw.githubusercontent.com/95ulisse/dns-operator/master/config/release/latest/all-in-one.yaml Verifying the installation \u00b6 If the deployment went smoothly, you should see a single dns-operator pod marked as Ready . $ kubectl get deployments/dns-operator -n dns-operator NAME READY UP-TO-DATE AVAILABLE AGE dns-operator 1/1 1 1 1m Configuring your first provider \u00b6 Before you can start managing your DNS records, you need to configure at least one DNSProvider . Go to the Quick Start section to learn how to configure one.","title":"Installation Guide"},{"location":"getting-started/install/#installing-dns-operator","text":"dns-operator runs in your cluster a regular deployment. It utilizes CustomResourceDefinitions to provide the new DNSProvider and DNSResource that you will later use. It is deployed with regular Kubernetes YAML manifests.","title":"Installing dns-operator"},{"location":"getting-started/install/#installing-the-manifests","text":"To install dns-operator in your cluster, use the all-in-one manifest. This will install the new CRDs and correctly setup RBAC roles. $ kubectl apply -f https://raw.githubusercontent.com/95ulisse/dns-operator/master/config/release/latest/all-in-one.yaml","title":"Installing the manifests"},{"location":"getting-started/install/#verifying-the-installation","text":"If the deployment went smoothly, you should see a single dns-operator pod marked as Ready . $ kubectl get deployments/dns-operator -n dns-operator NAME READY UP-TO-DATE AVAILABLE AGE dns-operator 1/1 1 1 1m","title":"Verifying the installation"},{"location":"getting-started/install/#configuring-your-first-provider","text":"Before you can start managing your DNS records, you need to configure at least one DNSProvider . Go to the Quick Start section to learn how to configure one.","title":"Configuring your first provider"},{"location":"getting-started/quick-start/","text":"Quick Start \u00b6 Note This section assumes that you have already installed the operator as described in Install . Configuring your first provider \u00b6 Let's start by creating a new namespace to hold our test resources. kubectl create namespace dns-operator-test The first step is to configure a new DNSProvider . As an example, we will configure a DNSProvider that uses Cloudflare as the backing provider. apiVersion : dns.k8s.marcocameriero.net/v1alpha1 kind : DNSProvider metadata : name : cf-provider # Name of the provider namespace : dns-operator-test spec : zones : # Zones that this provider will be responsible for - example.com cloudflare : apiTokenSecretRef : name : cf-provider-api-token # Secret containing the Cloudflare API Token key : token --- apiVersion : v1 kind : Secret data : token : XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX # Your Cloudflare API Token metadata : name : cf-provider-api-token namespace : dns-operator-test To check whether the provider we just deployed is ready to serve registration requests, check its Ready condition. When the provider is marked as Ready , all the checks passed, and we can start deploying the records. In case something is wrong in the configuration of the provider, an event will explain the details of the error. $ kubectl describe dnsprovider/cf-provider -n dns-operator-test [...] Name: cf-provider Namespace: dns-operator-test API Version: dns.k8s.marcocameriero.net/v1alpha1 Kind: DNSProvider Spec: Cloudflare: API Token Secret Ref: Key: token Name: cf-provider-api-token Zones: example.com Status: Conditions: Last Transition Time: 2021-02-20T17:13:18Z Last Update Time: 2021-02-20T17:13:18Z Message: Ready to register DNS records Reason: Ready Status: True Type: Ready Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Ready 12s dns.k8s.marcocameriero.net Ready to register DNS records Deploying your records \u00b6 Let's say we want to deploy a new A record for foo.example.com . Create and deploy the following DNSRecord to create a new A record for foo.example.com pointing to 1.1.1.1 . apiVersion : dns.k8s.marcocameriero.net/v1alpha1 kind : DNSRecord metadata : name : foo namespace : dns-operator-test spec : providerRef : name : cf-provider # Use the Cloudflare provider we defined earlier name : foo.example.com rrset : a : - 1.1.1.1 To check whether the DNS record registration was successful or not, we can check the Ready condition of the DNSRecord resource: $ kubectl describe dnsrecord/foo -n dns-operator-test [...] Name: foo Namespace: dns-operator-test API Version: dns.k8s.marcocameriero.net/v1alpha1 Kind: DNSRecord Spec: Name: foo.example.com Provider Ref: Name: cf-provider Rrset: A: 1.1.1.1 Status: Conditions: Last Transition Time: 2021-02-20T18:19:34Z Last Update Time: 2021-02-20T18:19:34Z Message: DNS record registered Reason: Ready Status: True Type: Ready Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Registered 22s dns.k8s.marcocameriero.net DNS record correclty registered We can also check that the records are actually visible. $ dig +short foo.example.com 1.1.1.1 When you update the DNSRecord resource, the actual DNS records registered on your provider will be automatically kept in sync. For example, change the spec of the DNSRecord we just created to: $ kubectl edit dnsprovider/cf-provider -n dns-operator-test [...] spec: rrset: a: - 1.1.1.1 - 2.2.2.2 And voil\u00e0. $ dig +short foo.example.com 1.1.1.1 2.2.2.2 Important A single DNSRecord resource describes a whole RRset , i.e., all the records of the same name and the same type in a zone. This means that if you register an A record for foo.example.com with dns-operator , then dns-operator expects to manage all the A records for foo.example.com . Cleanup test resources \u00b6 If you followed along this tutorial, remember to clean up the test resources. kubectl delete namespace dns-operator-test","title":"Quick Start"},{"location":"getting-started/quick-start/#quick-start","text":"Note This section assumes that you have already installed the operator as described in Install .","title":"Quick Start"},{"location":"getting-started/quick-start/#configuring-your-first-provider","text":"Let's start by creating a new namespace to hold our test resources. kubectl create namespace dns-operator-test The first step is to configure a new DNSProvider . As an example, we will configure a DNSProvider that uses Cloudflare as the backing provider. apiVersion : dns.k8s.marcocameriero.net/v1alpha1 kind : DNSProvider metadata : name : cf-provider # Name of the provider namespace : dns-operator-test spec : zones : # Zones that this provider will be responsible for - example.com cloudflare : apiTokenSecretRef : name : cf-provider-api-token # Secret containing the Cloudflare API Token key : token --- apiVersion : v1 kind : Secret data : token : XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX # Your Cloudflare API Token metadata : name : cf-provider-api-token namespace : dns-operator-test To check whether the provider we just deployed is ready to serve registration requests, check its Ready condition. When the provider is marked as Ready , all the checks passed, and we can start deploying the records. In case something is wrong in the configuration of the provider, an event will explain the details of the error. $ kubectl describe dnsprovider/cf-provider -n dns-operator-test [...] Name: cf-provider Namespace: dns-operator-test API Version: dns.k8s.marcocameriero.net/v1alpha1 Kind: DNSProvider Spec: Cloudflare: API Token Secret Ref: Key: token Name: cf-provider-api-token Zones: example.com Status: Conditions: Last Transition Time: 2021-02-20T17:13:18Z Last Update Time: 2021-02-20T17:13:18Z Message: Ready to register DNS records Reason: Ready Status: True Type: Ready Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Ready 12s dns.k8s.marcocameriero.net Ready to register DNS records","title":"Configuring your first provider"},{"location":"getting-started/quick-start/#deploying-your-records","text":"Let's say we want to deploy a new A record for foo.example.com . Create and deploy the following DNSRecord to create a new A record for foo.example.com pointing to 1.1.1.1 . apiVersion : dns.k8s.marcocameriero.net/v1alpha1 kind : DNSRecord metadata : name : foo namespace : dns-operator-test spec : providerRef : name : cf-provider # Use the Cloudflare provider we defined earlier name : foo.example.com rrset : a : - 1.1.1.1 To check whether the DNS record registration was successful or not, we can check the Ready condition of the DNSRecord resource: $ kubectl describe dnsrecord/foo -n dns-operator-test [...] Name: foo Namespace: dns-operator-test API Version: dns.k8s.marcocameriero.net/v1alpha1 Kind: DNSRecord Spec: Name: foo.example.com Provider Ref: Name: cf-provider Rrset: A: 1.1.1.1 Status: Conditions: Last Transition Time: 2021-02-20T18:19:34Z Last Update Time: 2021-02-20T18:19:34Z Message: DNS record registered Reason: Ready Status: True Type: Ready Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Registered 22s dns.k8s.marcocameriero.net DNS record correclty registered We can also check that the records are actually visible. $ dig +short foo.example.com 1.1.1.1 When you update the DNSRecord resource, the actual DNS records registered on your provider will be automatically kept in sync. For example, change the spec of the DNSRecord we just created to: $ kubectl edit dnsprovider/cf-provider -n dns-operator-test [...] spec: rrset: a: - 1.1.1.1 - 2.2.2.2 And voil\u00e0. $ dig +short foo.example.com 1.1.1.1 2.2.2.2 Important A single DNSRecord resource describes a whole RRset , i.e., all the records of the same name and the same type in a zone. This means that if you register an A record for foo.example.com with dns-operator , then dns-operator expects to manage all the A records for foo.example.com .","title":"Deploying your records"},{"location":"getting-started/quick-start/#cleanup-test-resources","text":"If you followed along this tutorial, remember to clean up the test resources. kubectl delete namespace dns-operator-test","title":"Cleanup test resources"},{"location":"guides/build/","text":"Build from source \u00b6 Note dns-operator is built using Kubebuilder . Clone the repository and use make to build the source. $ git clone https://github.com/95ulisse/dns-operator.git $ cd dns-operator $ make You can then run the operator either out-of-cluster or in-cluster: out-of-cluster , by directly running the compiled binary (it will connect to the cluster configured for your kubectl ). This is the recommended method, as it is way simpler and faster for debugging. $ make run ENABLE_WEBHOOKS = false in-cluster , by building a Docker image and deploying the operator as a workload on your cluster. $ make docker-build IMG = custom/image-name:tag $ make docker-push IMG = custom/image-name:tag $ make deploy # This automatically installs CRDs and configures RBAC for dns-operator Building the docs \u00b6 Note This documentation is written using MkDocs and MkDocs Material . Go to the docs directory and spin up a local server to test documentation. $ cd docs $ make docs-serve # Docs will be available on http://localhost:8000/","title":"Build from source"},{"location":"guides/build/#build-from-source","text":"Note dns-operator is built using Kubebuilder . Clone the repository and use make to build the source. $ git clone https://github.com/95ulisse/dns-operator.git $ cd dns-operator $ make You can then run the operator either out-of-cluster or in-cluster: out-of-cluster , by directly running the compiled binary (it will connect to the cluster configured for your kubectl ). This is the recommended method, as it is way simpler and faster for debugging. $ make run ENABLE_WEBHOOKS = false in-cluster , by building a Docker image and deploying the operator as a workload on your cluster. $ make docker-build IMG = custom/image-name:tag $ make docker-push IMG = custom/image-name:tag $ make deploy # This automatically installs CRDs and configures RBAC for dns-operator","title":"Build from source"},{"location":"guides/build/#building-the-docs","text":"Note This documentation is written using MkDocs and MkDocs Material . Go to the docs directory and spin up a local server to test documentation. $ cd docs $ make docs-serve # Docs will be available on http://localhost:8000/","title":"Building the docs"},{"location":"guides/cloudflare/","text":"Configuring the Cloudflare provider \u00b6 To use Cloudflare, you can configure one of two different authentication credentials: API Tokens , which allow finer control and application-specific permessions to certain zones and resources. API Keys , which are globally-scoped keys that carry the same permissions of you whole account. API Tokens are generally more recommendable for their higher livel of security with respect to API Keys. Using an API Token \u00b6 Create a new API Token from you Cloudflare dashboard at My Profile > API Tokens > Create Token . The minimum set of permissions required for dns-operator to correctly funcion are: Permissions: Zone > Zone > Read Zone > DNS > Edit Zone Resources: Include > Specific zone > <Name of the zone> (or alternatively, grant access to all zones by selecting All zones ) Once you have your new API Token, store it in a Kubernetes secret: apiVersion : v1 kind : Secret metadata : name : cf-provider-api-token type : Opaque data : token : XXXXXXXXXXXXXXXXX # Base64 encoded And then reference it in your DNSProvider : apiVersion : dns.k8s.marcocameriero.net/v1alpha1 kind : DNSProvider metadata : name : cf-provider spec : zones : # These zones must be included in the list of authorized zones for the token - '[...]' cloudflare : apiTokenSecretRef : name : cf-provider-api-token key : token Using an API Key \u00b6 View you account key at My Profile > API Tokens > Global API Key > View . Copy the key and store in in a Kubernetes secret: apiVersion : v1 kind : Secret metadata : name : cf-provider-api-key type : Opaque data : key : XXXXXXXXXXXXXXXXX # Base64 encoded And then reference it in your DNSProvider : apiVersion : dns.k8s.marcocameriero.net/v1alpha1 kind : DNSProvider metadata : name : cf-provider spec : zones : - '[...]' cloudflare : email : your-cloudflare-email@example.com apiKeySecretRef : name : cf-provider-api-key key : key","title":"Usage with Cloudflare"},{"location":"guides/cloudflare/#configuring-the-cloudflare-provider","text":"To use Cloudflare, you can configure one of two different authentication credentials: API Tokens , which allow finer control and application-specific permessions to certain zones and resources. API Keys , which are globally-scoped keys that carry the same permissions of you whole account. API Tokens are generally more recommendable for their higher livel of security with respect to API Keys.","title":"Configuring the Cloudflare provider"},{"location":"guides/cloudflare/#using-an-api-token","text":"Create a new API Token from you Cloudflare dashboard at My Profile > API Tokens > Create Token . The minimum set of permissions required for dns-operator to correctly funcion are: Permissions: Zone > Zone > Read Zone > DNS > Edit Zone Resources: Include > Specific zone > <Name of the zone> (or alternatively, grant access to all zones by selecting All zones ) Once you have your new API Token, store it in a Kubernetes secret: apiVersion : v1 kind : Secret metadata : name : cf-provider-api-token type : Opaque data : token : XXXXXXXXXXXXXXXXX # Base64 encoded And then reference it in your DNSProvider : apiVersion : dns.k8s.marcocameriero.net/v1alpha1 kind : DNSProvider metadata : name : cf-provider spec : zones : # These zones must be included in the list of authorized zones for the token - '[...]' cloudflare : apiTokenSecretRef : name : cf-provider-api-token key : token","title":"Using an API Token"},{"location":"guides/cloudflare/#using-an-api-key","text":"View you account key at My Profile > API Tokens > Global API Key > View . Copy the key and store in in a Kubernetes secret: apiVersion : v1 kind : Secret metadata : name : cf-provider-api-key type : Opaque data : key : XXXXXXXXXXXXXXXXX # Base64 encoded And then reference it in your DNSProvider : apiVersion : dns.k8s.marcocameriero.net/v1alpha1 kind : DNSProvider metadata : name : cf-provider spec : zones : - '[...]' cloudflare : email : your-cloudflare-email@example.com apiKeySecretRef : name : cf-provider-api-key key : key","title":"Using an API Key"},{"location":"guides/expose-an-application/","text":"Exposing an application \u00b6 Let's say you have an application running on your cluster, and you want to expose it on the internet with a public domain name. apiVersion : apps/v1 kind : Deployment metadata : name : my-app spec : selector : matchLabels : app : my-app template : metadata : labels : app : my-app spec : containers : - name : my-app image : my-app:1.0 ports : - containerPort : 8080 Create a LoadBalancer service to expose the app: apiVersion : v1 kind : Service metadata : name : my-app spec : type : LoadBalancer ports : - port : 80 targetPort : 8080 selector : app : my-app Note We used here a LoadBalancer service just for simplicity. There are many other ways to get traffic inside your cluster. For more info about services,check the official documentation . When the load balancer is ready, use kubectl to retrive the external IP. $ kubectl get service my-app NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE my-app LoadBalancer 172.16.18.129 1.1.1.1 80:30773/TCP 1m Use the external IP to setup a DNSRecord pointing to the load balancer. apiVersion : dns.k8s.marcocameriero.net/v1alpha1 kind : DNSRecord metadata : name : my-app spec : providerRef : name : my-provider name : my-app.example.com rrset : a : - 1.1.1.1 The app will now be reachable on: http://my-app.example.com","title":"Exposing an application"},{"location":"guides/expose-an-application/#exposing-an-application","text":"Let's say you have an application running on your cluster, and you want to expose it on the internet with a public domain name. apiVersion : apps/v1 kind : Deployment metadata : name : my-app spec : selector : matchLabels : app : my-app template : metadata : labels : app : my-app spec : containers : - name : my-app image : my-app:1.0 ports : - containerPort : 8080 Create a LoadBalancer service to expose the app: apiVersion : v1 kind : Service metadata : name : my-app spec : type : LoadBalancer ports : - port : 80 targetPort : 8080 selector : app : my-app Note We used here a LoadBalancer service just for simplicity. There are many other ways to get traffic inside your cluster. For more info about services,check the official documentation . When the load balancer is ready, use kubectl to retrive the external IP. $ kubectl get service my-app NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE my-app LoadBalancer 172.16.18.129 1.1.1.1 80:30773/TCP 1m Use the external IP to setup a DNSRecord pointing to the load balancer. apiVersion : dns.k8s.marcocameriero.net/v1alpha1 kind : DNSRecord metadata : name : my-app spec : providerRef : name : my-provider name : my-app.example.com rrset : a : - 1.1.1.1 The app will now be reachable on: http://my-app.example.com","title":"Exposing an application"},{"location":"reference/dnsprovider/","text":"DNSProvider Resource \u00b6 TODO","title":"DNSProvider Resource"},{"location":"reference/dnsprovider/#dnsprovider-resource","text":"TODO","title":"DNSProvider Resource"},{"location":"reference/dnsrecord/","text":"DNSRecord Resource \u00b6 TODO","title":"DNSRecord Resource"},{"location":"reference/dnsrecord/#dnsrecord-resource","text":"TODO","title":"DNSRecord Resource"}]}